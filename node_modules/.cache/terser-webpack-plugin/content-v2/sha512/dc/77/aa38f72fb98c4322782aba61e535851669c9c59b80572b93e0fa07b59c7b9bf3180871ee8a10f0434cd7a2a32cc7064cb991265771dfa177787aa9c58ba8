{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{800:function(v,_,a){\"use strict\";a.r(_);var t=a(1),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h3\",{attrs:{id:\"aaa\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aaa\"}},[v._v(\"#\")]),v._v(\" AAA\")]),v._v(\" \"),a(\"p\",[v._v(\"未组合的十进制加法调整指令 AAA(ASCII Adgust for Addition)\\n格式: AAA\\n功能: 对两个组合的十进制数相加运算(存在AL中)的结果进行调整,产生一个未组合的十进制数放在AX中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"组合的十进制数和未组合的十进制数:在计算中,十进制数可用四位二进制数编码,称为BCD码.\\n当一个节(8位)中存放一位BCD码,且放在字节的低4位, 高4位为时称为未组合的BCD码.\")]),v._v(\" \"),a(\"li\",[v._v(\"AAA的调整操作\\n若(AL) and 0FH>9 或 AF=1,则调整如下:\\n(AL)<--(AL)+6,(AH)<--(AH)+1,AF=1,CF<--AF,(AL)<--(AL) and 0FH\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"aad\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aad\"}},[v._v(\"#\")]),v._v(\" AAD\")]),v._v(\" \"),a(\"p\",[v._v(\"未组合十进制数除法调整指令 AAD(ASCII Adjust for Division)\\n格式: AAD\\n功能: 在除法指令前对AX中的两个未组合十进制数进行调整,以便能用DIV指令实现两个未组合的十进制数的除法运算,其结果为未组合的十进制数,商(在AL中)和余数(在AH中).\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"AAD指令是在执行除法DIV之前使用的,以便得到二进制结果存于AL中,然后除以OPRD,得到的商在AL中,余数在AH中.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: MOV BL,5\\nMOV AX,0308H\\nAAD ;(AL)<--1EH+08H=26H,(AH)<--0\\nDIV BL ;商＝07H--\\x3e(AL),余数＝03H--\\x3e(AH).\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"aam\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aam\"}},[v._v(\"#\")]),v._v(\" AAM\")]),v._v(\" \"),a(\"p\",[v._v(\"未组合十进制数乘法调整指令 AAM(ASCII Adjust MULtiply)\\n格式: AAM\\n功能: 对两个未组合的十进制数相乘后存于AX中的结果进行调整,产生一个未组合的十进制数存在AL中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"实际上是两个未组合的十进制数字节相乘,一个0～9的数与另一个0～9的数相乘其积最大为81.为了得到正确的结果,应进行如下调整:\\n乘积: (AH)<--(AL)/10\\n(AL)<--(AL)MOD10\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令应跟在MUL指令后使用,乘积的两位十进制结果,高位放在AH中,低位放在AL中.AH内容是MUL指令的结果被10除的商,即(AL)/10,而最后的AL内容是乘积被10整除的余数(即个位数).\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"aas\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#aas\"}},[v._v(\"#\")]),v._v(\" AAS\")]),v._v(\" \"),a(\"p\",[v._v(\"未组合十进制减法调整指令 AAS(ASCII Adjust for Subtraction)\\n格式: AAS\\n功能: 对两个未组合十进制数相减后存于AL中的结果进行调整,调整后产生一个未组合的十进制数数且仍存于AL中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令影响标志位CF及AF.\")]),v._v(\" \"),a(\"li\",[v._v(\"调整操作\\n若(AL) and 0FH > 9 或 AF=1\\n则(AL)<--(AL)-6,(AH)<--(AH)-1,CF<--AF,(AL)<--(AL) and 0FH,\\n否则(AL)<--(AL) and 0FH\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"adc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#adc\"}},[v._v(\"#\")]),v._v(\" ADC\")]),v._v(\" \"),a(\"p\",[v._v(\"带进位加法指令 ADC(Addition Carry)\\n格式: ADC OPRD1,OPRD2\\n功能: OPRD1<--OPRD1 + OPRD2 + CF\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数.\\nOPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"OPRD1和OPRD2均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的,但不允许两个都是存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响.以上标志也称为结果标志.\")]),v._v(\" \"),a(\"li\",[v._v(\"该指令对标志位的影响同ADD指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"add\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#add\"}},[v._v(\"#\")]),v._v(\" ADD\")]),v._v(\" \"),a(\"p\",[v._v(\"加法指令 ADD(Addition)\\n格式: ADD OPRD1,OPRD2\\n功能: 两数相加\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数.\\nOPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"OPRD1和OPRD2均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响.以上标志也称为结果标志.加法指令适用于无符号数或有符号数的加法运算.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"and\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#and\"}},[v._v(\"#\")]),v._v(\" AND\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑与运算指令 AND\\n格式: AND OPRD1,OPRD2\\n功能: 对两个操作数实现按位逻辑与运算,结果送至目的操作数.本指令可以进行字节或字的‘与’运算,\\nOPRD1<--OPRD1 and OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"目的操作数OPRD1为任一通用寄存器或存储器操作数.源操作数OPRD2为立即数,任一通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: AND AL,0FH ;(AL)<--(AL) AND 0FH\\nAND AX,BX ;(AX)<--(AX) AND (BX)\\nAND DX,BUFFER[SI+BX]\\nAND BETA[BX],00FFH\\n注意: 两数相与，有一个数假则值为假\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"call\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#call\"}},[v._v(\"#\")]),v._v(\" CALL\")]),v._v(\" \"),a(\"p\",[v._v(\"过程调用指令 CALL\\n格式: CALL OPRD\\n功能: 过程调用指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为过程的目的地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"过程调用可分为段内调用和段间调用两种.寻址方式也可以分为直接寻址和间接寻址两种.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cbw\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cbw\"}},[v._v(\"#\")]),v._v(\" CBW\")]),v._v(\" \"),a(\"p\",[v._v(\"字节扩展指令 CBW(Convert Byte to Word)\\n格式: CBW\\n功能: 将字节扩展为字,即把AL寄存器的符号位扩展到AH中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"两个字节相除时,先使用本指令形成一个双字节长的被除数.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: MOV AL,25\\nCBW\\nIDIV BYTE PTR DATA1\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"clc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#clc\"}},[v._v(\"#\")]),v._v(\" CLC\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cld\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cld\"}},[v._v(\"#\")]),v._v(\" CLD\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cli\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cli\"}},[v._v(\"#\")]),v._v(\" CLI\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cmc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cmc\"}},[v._v(\"#\")]),v._v(\" CMC\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cmp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cmp\"}},[v._v(\"#\")]),v._v(\" CMP\")]),v._v(\" \"),a(\"p\",[v._v(\"比效指令 CMP(CoMPare)\\n格式: CMP OPRD1,OPRD2\\n功能: 对两数进行相减,进行比较.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1为任意通用寄存器或存储器操作数.\\nOPRD2为任意通用寄存器或存储器操作数,立即数也可用作源操作数OPRD2.\")]),v._v(\" \"),a(\"li\",[v._v(\"对标志位的影响同SUB指令,完成的操作与SUB指令类似,唯一的区别是不将OPRD1-OPRD2的结果送回OPRD1,而只是比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"在8088/8086指令系统中,专门提供了一组根据带符号数比较大小后,实现条件转移的指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cmps\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cmps\"}},[v._v(\"#\")]),v._v(\" CMPS\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串比较指令\\n格式: CMPS OPRD1,OPRD2\\nCMPSB\\nCMPSW\\n功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身.\\n同时SI,DI将自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cmpsb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cmpsb\"}},[v._v(\"#\")]),v._v(\" CMPSB\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串比较指令\\n格式: CMPS OPRD1,OPRD2\\nCMPSB\\nCMPSW\\n功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身.\\n同时SI,DI将自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cmpsw\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cmpsw\"}},[v._v(\"#\")]),v._v(\" CMPSW\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串比较指令\\n格式: CMPS OPRD1,OPRD2\\nCMPSB\\nCMPSW\\n功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身.\\n同时SI,DI将自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"cwd\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cwd\"}},[v._v(\"#\")]),v._v(\" CWD\")]),v._v(\" \"),a(\"p\",[v._v(\"字扩展指令 CWD(Convert Word to Double Word)\\n格式: CWD\\n功能: 将字扩展为双字长,即把AX寄存器的符号位扩展到DX中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"两个字或字节相除时,先用本指令形成一个双字长的的被除数.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: 在B1、B2、B3字节类型变量中,分别存有8们带符号数a、b、c,实现(a*b+c)/a运算。\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"daa\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#daa\"}},[v._v(\"#\")]),v._v(\" DAA\")]),v._v(\" \"),a(\"p\",[v._v(\"组合的十进制加法调整指令 DAA(Decimal Adjust for Addition)\\n格式: DAA\\n功能: 对AL中的两个组合进制数相加的结果进行调整,调整结果仍放在AL中,进位标志放在CF中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"调整操作如下\\n(1) 若(AL) and 0FH>9 或 AF=1,则(AL)<--(AL)+6,AF<--1,对低四位的调整.\\n(2) 若(AL) and 0F0H>90H 或 CF=1,则(AL)<--(AL)+60H,CF<--1.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: (AL)=18H,(BL)=06H\\nADD AL,BL ; (AL)<--(AL)+(BL) ; (AL)=1EH\\nDAA ; (AL)\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"das\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#das\"}},[v._v(\"#\")]),v._v(\" DAS\")]),v._v(\" \"),a(\"p\",[v._v(\"组合十进制减法调整指令 DAS(Decimal Adjust for Subtraction)\\n格式: DAS\\n功能: 对两个组合十进制数相减后存于AL中的结果进行调整,调整后产生一个组合的十进制数且仍存于AL中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\n调整操作\\n若(AL) and 0FH > 9 或 AF=1,则(AL)<--(AL)-6,AF=1\\n若(AL) and 0F0H > 90H 或 CF=1,则(AL)<--(AL)-60,CF=1\")]),v._v(\" \"),a(\"p\",[v._v(\"DEC\")]),v._v(\" \"),a(\"p\",[v._v(\"减一指令 DEC(Decrement by 1)\\n格式: DEC OPRD\\n功能: OPRD<--OPRD-1\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD 为寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"这条指令执行结果影响AF、OF、PF、SF、ZF标志位，但不影响CF标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例 DEC AX\\nDEC CL\\nDEC WORD PTR[DI]\\nDEC ALFA[DI+BX]\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"div\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#div\"}},[v._v(\"#\")]),v._v(\" DIV\")]),v._v(\" \"),a(\"p\",[v._v(\"无符号数除法指令 DIV(DIVision)\\n格式: DIV OPRD\\n功能: 实现两个无符号二进制数除法运算.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为任一个通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"字节相除,被除数在AX中;字相除,被除数在DX,AX中,除数在OPRD中.\\n字节除法: (AL)<--(AX)/OPRD,(AH)<--(AX)MOD OPRD\\n字除法: (AX)<--(DX)(AX)/OPRD,(DX)<--(DX)(AX) MOD OPRD\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"esc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#esc\"}},[v._v(\"#\")]),v._v(\" ESC\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器交权指令 ESC\\n格式: ESC EXTOPRD,OPRD\\n功能: 使用本指令可以实现协处理器出放在ESC指令代码中的6位常数,该常数指明协处理器要完成的功能.\\n当源操作数为存储器变量时,则取出该存储器操作数传送给协处理器.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中EXTOPRD为外部操作码,OPRD为源操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"hlt\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hlt\"}},[v._v(\"#\")]),v._v(\" HLT\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器暂停指令 HLT\\n格式: HLT\\n功能: 使处理器处于暂时停机状态.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令不影响标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"由执行HLT引起的暂停,只有RESET(复位)、NMI(非屏蔽中断请求)、INTR(可屏蔽的外部中断请求)信号可以使\\n其退出暂停状态.它可用于等待中断的到来或多机系统的同步操作.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"idiv\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#idiv\"}},[v._v(\"#\")]),v._v(\" IDIV\")]),v._v(\" \"),a(\"p\",[v._v(\"带符号数除法指定 IDIV(Interger DIVision)\\n格式: IDIV OPRD\\n功能: 这实现两个带符号数的二进制除法运算.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为任一通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"理由与IMUL相同,只有IDIV指令,才能得到符号数相除的正确结果.\")]),v._v(\" \"),a(\"li\",[v._v(\"当被除数为8位,在进行字节除法前,应把AL的符号位扩充至AH中.在16位除法时,若被除数为16位,则应将AX中的符号位扩到DX中.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"imul\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#imul\"}},[v._v(\"#\")]),v._v(\" IMUL\")]),v._v(\" \"),a(\"p\",[v._v(\"带符号数乘法指令 IMUL(Integer MULtiply)\\n格式: IMUL OPRD\\n功能: 完成两个带符号数的相乘\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为任一通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"MUL指令对带符号相乘时,不能得到正确的结果.\\n例如: (AL)=255\\n(CL)=255\\nMUL CL\\n(AX)=65025\\n注意: 这对无符号数讲,结果是正确的,但对带符号数讲,相当于(-1)*(-1)结果应为+1,而65025对应的带符号数为-511,显然是不正确的.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"in\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#in\"}},[v._v(\"#\")]),v._v(\" IN\")]),v._v(\" \"),a(\"p\",[v._v(\"输入指令 IN\\n格式: IN AL,n ;(AL)<--(n)\\nIN AX,n ;(AX)<--(n+1),(n)\\nIN AL,DX ;(AL)<--[(DX)]\\nIN AX,DX ;(AX)<--[(DX)+1],[(DX)]\\n功能: 输入指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中n为8位的端口地址,当字节输入时,将端口地址n+1的内容送至AH中,端口地址n的内容送AL中.\")]),v._v(\" \"),a(\"li\",[v._v(\"端口地址也可以是16位的,但必须将16位的端口地址送入DX中.当字节寻址时,由DX内容作端口地址的内容送至AL中;\\n当输入数据字时,[(DX)+1]送AH,[(DX)]送AL中,用符号:(AX)<--[(DX)+1],[(DX)]表示.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"inc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#inc\"}},[v._v(\"#\")]),v._v(\" INC\")]),v._v(\" \"),a(\"p\",[v._v(\"加1指令 INC(INCrement by 1)\\n格式: INC OPRD\\n功能: OPRD<--OPRD+1\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD 为寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"这条指令执行结果影响AF、OF、PF、SF、ZF标志位,但不影响CF标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例:\\nINC SI;(SI)<--(SI)+1\\nINC WORD PTR[BX]\\nINC BYTE PTR[BX+DI]\\nINC CL;(CL)<--(CL)+1\\n注意: 上述第二,三两条指令,是对存储字及存储字节的内容加1以替代原来的内容.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"int\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#int\"}},[v._v(\"#\")]),v._v(\" INT\")]),v._v(\" \"),a(\"p\",[v._v(\"软中断指令 INT\\n格式: INT n 其中n为软中断的类型号.\\n功能: 本指令将产生一个软中断,把控制转向一个类型号为n的软中断,该中断处理程序入口地址在中断向量表的n*4地址\\n处的二个存储器字(4个单元)中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 操作过程与INTO指令雷同,只需将10H改为n*4即可.所以,本指令也将影响标志位IF及TF.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"into\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#into\"}},[v._v(\"#\")]),v._v(\" INTO\")]),v._v(\" \"),a(\"p\",[v._v(\"溢出中断指令 INTO(INTerrupt if Overflow)\\n格式: INTO\\n功能: 本指令检测OF标志位,当OF=1时,说明已发生溢出,立即产生一个中断类型4的中断,当OF＝0时,本指令不起作用.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令影响标志位IF及TF.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令可用于溢出处理,当OF=1时,产生一个类型4的软中断.在中断处理程序中完成溢出的处理操作.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"iret\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#iret\"}},[v._v(\"#\")]),v._v(\" IRET\")]),v._v(\" \"),a(\"p\",[v._v(\"中断返回指令 IRET\\n格式: IRET\\n功能: 用于中断处理程序中,从中断程序的断点处返回,继续执行原程序.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令将影响所有标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"无论是软中断,还是硬中断,本指令均可使其返回到中断程序的断点处继续执行原程序.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"ja\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ja\"}},[v._v(\"#\")]),v._v(\" JA\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JA/JNBE\\n格式: JA/JNBE标号\\n功能: 为高于/不低于等于的转移指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"例如两个符号数a,b比较时,a>b(即CF=0,ZF=0)时转移.因为单一标志位CF=0,只表示a>=b.\")]),v._v(\" \"),a(\"li\",[v._v(\"JA/JNBE是同一条指令的两种不同的助记符.\")]),v._v(\" \"),a(\"li\",[v._v(\"该指令用于无符号数进行条件转移\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jae\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jae\"}},[v._v(\"#\")]),v._v(\" JAE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JAE/JNB\\n格式: JAE/JNB 标号\\n功能: 为高于等于/不低于的转移指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"JAE/JNB是同一条指令的两种不同的助记符.\")]),v._v(\" \"),a(\"li\",[v._v(\"该指令用于无符号数进行条件转移.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jb\"}},[v._v(\"#\")]),v._v(\" JB\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JB/JNAE\\n格式: JB/JNAE 标号\\n功能: 低于/不高于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 该指令用于无符号数的条件转移\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jbe\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jbe\"}},[v._v(\"#\")]),v._v(\" JBE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JBE/JNA\\n格式: JBE/JNA 标号\\n功能: 低于等于/不高于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 该指令用于无符号数的条件转移\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jc\"}},[v._v(\"#\")]),v._v(\" JC\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令 JC\\n格式: JC 标号\\n功能: CF＝1,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JC为根据标志位CF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"je\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#je\"}},[v._v(\"#\")]),v._v(\" JE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JE/JZ\\n格式: JE/JZ标号\\n功能: ZF＝1,转至标号处执\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JE与JZ等价,它们是根据标志位ZF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JE,JZ均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jg\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jg\"}},[v._v(\"#\")]),v._v(\" JG\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JG/JNLE\\n格式: JG/JNLE 标号\\n功能: 大于/不小于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jge\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jge\"}},[v._v(\"#\")]),v._v(\" JGE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JGE/JNL\\n格式: JGE/JNL标号\\n功能: 大于等于/不小于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jl\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jl\"}},[v._v(\"#\")]),v._v(\" JL\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JL/JNGE\\n格式: JL/JNGE标号\\n功能: 小于/不大于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jle\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jle\"}},[v._v(\"#\")]),v._v(\" JLE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JLE/JNG\\n格式: JLE/JNG 标号\\n功能: 小于等于/不大于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jmp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jmp\"}},[v._v(\"#\")]),v._v(\" JMP\")]),v._v(\" \"),a(\"p\",[v._v(\"无条件转移指令JMP\\n格式: JMP OPRD\\n功能: JMP指令将无条件地控制程序转移到目的地址去执行.当目的地址仍在同一个代码段内,称为段内转移;当目标地址不在同一个代码段内,则称为段间转移.这两种情况都将产生不同的指令代码,以便能正确地生成目的地址,在段内转移时,指令只要能提供目的地址的段内偏移量即够了;而在段间转移时,指令应能提供目的地址的段地址及段内偏移地址值.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为转移的目的地址.程序转移到目的地址所指向的指令继续往下执行.\")]),v._v(\" \"),a(\"li\",[v._v(\"本组指令对标志位无影响.\")]),v._v(\" \"),a(\"li\",[v._v(\"<1> 段内直接转移指令: JMP NEAR 标号\\n<2> 段内间接转移指令: JMP OPRD\\n<3> 段间直接转移指令: JMP FAR 标号\\n<4> 段间间接转移指令:JMP OPRD其中的OPRD为存储器双字操作数.段间间接转移只能通过存储器操作数来实现.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jna\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jna\"}},[v._v(\"#\")]),v._v(\" JNA\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JBE/JNA\\n格式: JBE/JNA 标号\\n功能: 低于等于/不高于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 该指令用于无符号数的条件转移\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnae\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnae\"}},[v._v(\"#\")]),v._v(\" JNAE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JB/JNAE\\n格式: JB/JNAE 标号\\n功能: 低于/不高于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 该指令用于无符号数的条件转移\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnb\"}},[v._v(\"#\")]),v._v(\" JNB\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JAE/JNB\\n格式: JAE/JNB 标号\\n功能: 为高于等于/不低于的转移指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"JAE/JNB是同一条指令的两种不同的助记符.\")]),v._v(\" \"),a(\"li\",[v._v(\"该指令用于无符号数进行条件转移.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnbe\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnbe\"}},[v._v(\"#\")]),v._v(\" JNBE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JA/JNBE\\n格式: JA/JNBE标号\\n功能: 为高于/不低于等于的转移指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"例如两个符号数a,b比较时,a>b(即CF=0,ZF=0)时转移.因为单一标志位CF=0,只表示a>=b.\")]),v._v(\" \"),a(\"li\",[v._v(\"JA/JNBE是同一条指令的两种不同的助记符.\")]),v._v(\" \"),a(\"li\",[v._v(\"该指令用于无符号数进行条件转移\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnc\"}},[v._v(\"#\")]),v._v(\" JNC\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNC\\n格式: JNC标号\\n功能: CF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JNC为根据标志位CF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jne\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jne\"}},[v._v(\"#\")]),v._v(\" JNE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNE/JNZ\\n格式: JNE/JNZ 标号\\n功能: ZF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JNE与JNZ等价,它们是根据标志位ZF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JNE,JNZ均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jng\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jng\"}},[v._v(\"#\")]),v._v(\" JNG\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JLE/JNG\\n格式: JLE/JNG 标号\\n功能: 小于等于/不大于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnge\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnge\"}},[v._v(\"#\")]),v._v(\" JNGE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JL/JNGE\\n格式: JL/JNGE标号\\n功能: 小于/不大于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnl\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnl\"}},[v._v(\"#\")]),v._v(\" JNL\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JGE/JNL\\n格式: JGE/JNL标号\\n功能: 大于等于/不小于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnle\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnle\"}},[v._v(\"#\")]),v._v(\" JNLE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JG/JNLE\\n格式: JG/JNLE 标号\\n功能: 大于/不小于等于时转移\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 用于带符号数的条件转移指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jno\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jno\"}},[v._v(\"#\")]),v._v(\" JNO\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNO\\n格式: JNO 标号\\n功能: OF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JNO是根椐溢出标志位OF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnp\"}},[v._v(\"#\")]),v._v(\" JNP\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNP/JPO\\n格式: JNP/JPO 标号\\n功能: PF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JNP与JPO,它们是根据奇偶标志位PF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JNP,JPO均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jns\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jns\"}},[v._v(\"#\")]),v._v(\" JNS\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNS\\n格式: JNS 标号\\n功能: SF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JNS是根据符号标志位SF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jnz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jnz\"}},[v._v(\"#\")]),v._v(\" JNZ\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNE/JNZ\\n格式: JNE/JNZ 标号\\n功能: ZF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JNE与JNZ等价,它们是根据标志位ZF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JNE,JNZ均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jo\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jo\"}},[v._v(\"#\")]),v._v(\" JO\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JO\\n格式: JO 标号\\n功能: OF＝1,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JO是根椐溢出标志位OF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jp\"}},[v._v(\"#\")]),v._v(\" JP\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JP/JPE\\n格式: JP/JPE 标号\\n功能: PF＝1,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JP与JPE,它们是根据奇偶标志位PF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JP,JPE均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jpe\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jpe\"}},[v._v(\"#\")]),v._v(\" JPE\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JP/JPE\\n格式: JP/JPE 标号\\n功能: PF＝1,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JP与JPE,它们是根据奇偶标志位PF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JP,JPE均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jpo\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jpo\"}},[v._v(\"#\")]),v._v(\" JPO\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JNP/JPO\\n格式: JNP/JPO 标号\\n功能: PF＝0,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JNP与JPO,它们是根据奇偶标志位PF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JNP,JPO均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"js\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js\"}},[v._v(\"#\")]),v._v(\" JS\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JS\\n格式: JS 标号\\n功能: SF＝1,转至标号处执行\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: JS是根据符号标志位SF进行转移的指令\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"jz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jz\"}},[v._v(\"#\")]),v._v(\" JZ\")]),v._v(\" \"),a(\"p\",[v._v(\"条件转移指令JE/JZ\\n格式: JE/JZ标号\\n功能: ZF＝1,转至标号处执\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"指令JE与JZ等价,它们是根据标志位ZF进行转移的指令\")]),v._v(\" \"),a(\"li\",[v._v(\"JE,JZ均为一条指令的两种助记符表示方法\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lahf\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lahf\"}},[v._v(\"#\")]),v._v(\" LAHF\")]),v._v(\" \"),a(\"p\",[v._v(\"标志传送指令 LAHF\\n格式: LAHF\\n功能: 取FLAG标志寄存器低8位至AH寄存器.(AH)<--(FLAG)7~0\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 该指令不影响FLAG的原来内容,AH只是复制了原FLAG的低8位内容.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lds\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lds\"}},[v._v(\"#\")]),v._v(\" LDS\")]),v._v(\" \"),a(\"p\",[v._v(\"从存储器取出32位地址的指令 LDS\\n格式: LDS OPRD1,OPRD2\\n功能: 从存储器取出32位地址的指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\nOPRD1 为任意一个16位的寄存器.\\nOPRD2 为32位的存储器地址.\\n示例: LDS SI,ABCD\\nLDS BX,FAST[SI]\\nLDS DI,[BX]\\n注意: 上面LDS DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入DS,偏移地址送入DI.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lea\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lea\"}},[v._v(\"#\")]),v._v(\" LEA\")]),v._v(\" \"),a(\"p\",[v._v(\"有效地址传送指令 LEA\\n格式: LEA OPRD1,OPRD2\\n功能: 将源操作数给出的有效地址传送到指定的的寄存器中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1 为目的操作数,可为任意一个16位的通用寄存器.\\nOPRD2 为源操作数,可为变量名、标号或地址表达式.\\n示例: LEA BX,DATA1\\nLEA DX,BETA[BX+SI]\\nLEA BX BX,[BP],[DI]\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令对标志位无影响。\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"les\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#les\"}},[v._v(\"#\")]),v._v(\" LES\")]),v._v(\" \"),a(\"p\",[v._v(\"从存储器取出32位地址的指令 LES\\n格式: LES OPRD1,OPRD2\\n功能: 从存储器取出32位地址的指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\nOPRD1 为任意一个16位的寄存器.\\nOPRD2 为32位的存储器地址.\\n示例: LES SI,ABCD\\nLES BX,FAST[SI]\\nLES DI,[BX]\\n注意: 上面LES DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入ES,偏移地址送入DI.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lock\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lock\"}},[v._v(\"#\")]),v._v(\" LOCK\")]),v._v(\" \"),a(\"p\",[v._v(\"封锁总线指令 LOCK\\n格式: LOCK\\n功能: 指令是一个前缀,可放在指令的前面,告诉CPU在执行该指令时,不允许其它设备对总线进行访问.\")]),v._v(\" \"),a(\"p\",[v._v(\"无可用信息!用户可自行添加!\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"lods\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lods\"}},[v._v(\"#\")]),v._v(\" LODS\")]),v._v(\" \"),a(\"p\",[v._v(\"取字符串元素指令 LODS\\n格式: LODS OPRD 其中OPRD为源字符串符号地址.\\n功能: 把SI寻址的源串的数据字节送AL或数据字送AX中去, 并根据DF的值修改地址指针SI进行自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令不影响标志位.\")]),v._v(\" \"),a(\"li\",[v._v(\"当不使用操作数时,可用LODS(字节串)或LODSW(字串)指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"loop\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#loop\"}},[v._v(\"#\")]),v._v(\" LOOP\")]),v._v(\" \"),a(\"p\",[v._v(\"循环控制指令LOOP\\n格式: LOOP 标号\\n功能: (CX)<--(CX)-1,(CX)<>0,则转移至标号处循环执行, 直至(CX)=0,继续执行后继指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令是用CX寄存器作为计数器,来控制程序的循环.\")]),v._v(\" \"),a(\"li\",[v._v(\"它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"loope\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#loope\"}},[v._v(\"#\")]),v._v(\" LOOPE\")]),v._v(\" \"),a(\"p\",[v._v(\"循环控制指令LOOPZ/LOOPE\\n格式: LOOPZ/LOOPE 标号\\n功能: (CX)<--(CX)-1,(CX)<>0 且ZF＝1时,转至标号处循环\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令是用CX寄存器作为计数器,来控制程序的循环.\")]),v._v(\" \"),a(\"li\",[v._v(\"它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.\")]),v._v(\" \"),a(\"li\",[v._v(\"以上两种助记符等价.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"loopne\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#loopne\"}},[v._v(\"#\")]),v._v(\" LOOPNE\")]),v._v(\" \"),a(\"p\",[v._v(\"循环控制指令LOOPNZ/LOOPNE\\n格式: LOOPNZ/LOOPNE 标号\\n功能: (CX)<--(CX)-1,(CX)<>0 且ZF＝0时,转至标号处循环\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令是用CX寄存器作为计数器,来控制程序的循环.\")]),v._v(\" \"),a(\"li\",[v._v(\"它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.\")]),v._v(\" \"),a(\"li\",[v._v(\"以上两种助记符等价.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"loopnz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#loopnz\"}},[v._v(\"#\")]),v._v(\" LOOPNZ\")]),v._v(\" \"),a(\"p\",[v._v(\"循环控制指令LOOPNZ/LOOPNE\\n格式: LOOPNZ/LOOPNE 标号\\n功能: (CX)<--(CX)-1,(CX)<>0 且ZF＝0时,转至标号处循环\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令是用CX寄存器作为计数器,来控制程序的循环.\")]),v._v(\" \"),a(\"li\",[v._v(\"它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.\")]),v._v(\" \"),a(\"li\",[v._v(\"以上两种助记符等价.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"loopz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#loopz\"}},[v._v(\"#\")]),v._v(\" LOOPZ\")]),v._v(\" \"),a(\"p\",[v._v(\"循环控制指令LOOPZ/LOOPE\\n格式: LOOPZ/LOOPE 标号\\n功能: (CX)<--(CX)-1,(CX)<>0 且ZF＝1时,转至标号处循环\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令是用CX寄存器作为计数器,来控制程序的循环.\")]),v._v(\" \"),a(\"li\",[v._v(\"它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.\")]),v._v(\" \"),a(\"li\",[v._v(\"以上两种助记符等价.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"move\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#move\"}},[v._v(\"#\")]),v._v(\" MOVE\")]),v._v(\" \"),a(\"p\",[v._v(\"数据传送指令 MOV\\n格式: MOV OPRD1,OPRD2\\n功能: 本指令将一个源操作数送到目的操作数中,即OPRD1<--OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1 为目的操作数,可以是寄存器、存储器、累加器.\\nOPRD2 为源操作数,可以是寄存器、存储器、累加器和立即数.\")]),v._v(\" \"),a(\"li\",[v._v(\"MOV 指令以分为以下四种情况:\\n<1> 寄存器与寄存器之间的数据传送指令\\n<2> 立即数到通用寄存器数据传送指令\\n<3> 寄存器与存储器之间的数据传送指令\\n<4> 立即数到存储器的数据传送\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响状态标志位\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"movs\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#movs\"}},[v._v(\"#\")]),v._v(\" MOVS\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串传送指令 MOVS\\n格式: MOVS OPRD1,OPRD2\\nMOVSB\\nMOVSW\\n功能: OPRD1<--OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"字节串操作: 若DF=0,则作加, 若DF=1,则作减.\")]),v._v(\" \"),a(\"li\",[v._v(\"对字串操作时: 若DF=0,则作加,若DF=1,则作减,.\")]),v._v(\" \"),a(\"li\",[v._v(\"在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"movsb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#movsb\"}},[v._v(\"#\")]),v._v(\" MOVSB\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串传送指令 MOVS\\n格式: MOVS OPRD1,OPRD2\\nMOVSB\\nMOVSW\\n功能: OPRD1<--OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"字节串操作: 若DF=0,则作加, 若DF=1,则作减.\")]),v._v(\" \"),a(\"li\",[v._v(\"对字串操作时: 若DF=0,则作加,若DF=1,则作减,.\")]),v._v(\" \"),a(\"li\",[v._v(\"在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"movsw\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#movsw\"}},[v._v(\"#\")]),v._v(\" MOVSW\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串传送指令 MOVS\\n格式: MOVS OPRD1,OPRD2\\nMOVSB\\nMOVSW\\n功能: OPRD1<--OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD2为源串符号地址,OPRD1为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"字节串操作: 若DF=0,则作加, 若DF=1,则作减.\")]),v._v(\" \"),a(\"li\",[v._v(\"对字串操作时: 若DF=0,则作加,若DF=1,则作减,.\")]),v._v(\" \"),a(\"li\",[v._v(\"在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"mul\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mul\"}},[v._v(\"#\")]),v._v(\" MUL\")]),v._v(\" \"),a(\"p\",[v._v(\"无符号数乘法指令 MUL(MULtiply)\\n格式: MUL OPRD\\n功能: 乘法操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD为通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"OPRD为源操作数,即作乘数.目的操作数是隐含的,即被乘数总是指定为累加器AX或AL的内容.\")]),v._v(\" \"),a(\"li\",[v._v(\"16位乘法时,AX中为被乘数.8位乘法时,AL为被乘数.当16位乘法时,32位的乘积存于DX及AX中;8位乘法的16位乘积存于AX中.\")]),v._v(\" \"),a(\"li\",[v._v(\"操作过程: 字节相乘:(AX)<--(AL)*OPRD,当结果的高位字节(AH)不等于0时,则CF＝1、OF＝1.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"neg\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#neg\"}},[v._v(\"#\")]),v._v(\" NEG\")]),v._v(\" \"),a(\"p\",[v._v(\"取补指令 NEG(NEGate)\\n格式: NEG OPRD\\n功能: 对操作数OPRD进行取补操作,然后将结果送回OPRD.取补操作也叫作求补操作,就是求一个数的相反数的补码.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD为任意通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: (AL)=44H,取补后,(AL)=0BCH(-44H).\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志位CF、OF、SF、PF、ZF及AF.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"nop\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nop\"}},[v._v(\"#\")]),v._v(\" NOP\")]),v._v(\" \"),a(\"p\",[v._v(\"空操作指令 NOP\\n格式: NOP\\n功能: 本指令不产生任何结果,仅消耗几个时钟周期的时间,接着执行后续指令,常用于程序的延时等.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 本指令不影响标志位.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"not\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#not\"}},[v._v(\"#\")]),v._v(\" NOT\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑非运算指令 NOT\\n格式: NOT OPRD\\n功能: 完成对操作数按位求反运算(即0变1,1变0),结果关回原操作数.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD可为任一通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指梳令可以进行字或字节‘非’运算.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"or\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#or\"}},[v._v(\"#\")]),v._v(\" OR\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑或指令 OR\\n格式: OR OPRD1,OPRD2\\n功能: OR指令完成对两个操作数按位的‘或’运算,结果送至目的操作数中,本指令可以进行字节或字的‘或’运算.\\nOPRD1<--OPRD1 OR OPRD2.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD1,OPRD2含义与AND指令相同,对标志位的影响也与AND指令相同.\")]),v._v(\" \"),a(\"li\",[v._v(\"两数相或,有一个数为真则值为真.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"out\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#out\"}},[v._v(\"#\")]),v._v(\" OUT\")]),v._v(\" \"),a(\"p\",[v._v(\"输出指令 OUT\\n格式: OUT n,AL ;(n)<--(AL)\\n功能: 输出指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OUT n,AX ;(n+1),(n)<--(AX)\\nOUT DX,AL ;[(DX)]<--(AL)\\nOUT DX,AX ;[(DX)+1],[(DX)]<--(AX)\")]),v._v(\" \"),a(\"li\",[v._v(\"输入指令及输出指令对标志位都不影响.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"pop\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pop\"}},[v._v(\"#\")]),v._v(\" POP\")]),v._v(\" \"),a(\"p\",[v._v(\"堆栈操作指令 PUSH和POP\\n格式: PUSH OPRD\\nPOP OPRD\\n功能: 实现压入操作的指令是PUSH指令;实现弹出操作的指令是POP指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD为16位(字)操作数,可以是寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"POP指令的操作过程是: POP OPRD:OPRD<--((SP)),(SP)<--(SP)+2\\n它与压入操作相反,是先弹出栈顶的数顶,然后再修改指针SP的内容.\")]),v._v(\" \"),a(\"li\",[v._v(\"示例: POP AX\\nPOP DS\\nPOP DATA1 POP ALFA[BX][DI]\")]),v._v(\" \"),a(\"li\",[v._v(\"PUSH和POP指令对状态标志位没有影响.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"popf\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#popf\"}},[v._v(\"#\")]),v._v(\" POPF\")]),v._v(\" \"),a(\"p\",[v._v(\"标志传送指令 POPF\\n格式: POPF\\n功能: 本指令的功能与PUSHF相反,在子程序调用和中断服务程序中,往往用PUSHF指令保护FLAG的内容,用POPF指令将保护的FLAG内容恢复.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 如果对堆栈中的原FLAG内容进行修改,如对TF等标志位进行修改,然后再弹回标志位寄存器FLAG.这是通过指令修改TF标志的唯一方法.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"push\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#push\"}},[v._v(\"#\")]),v._v(\" PUSH\")]),v._v(\" \"),a(\"p\",[v._v(\"堆栈操作指令 PUSH和POP\\n格式: PUSH OPRD\\nPOP OPRD\\n功能: 实现压入操作的指令是PUSH指令;实现弹出操作的指令是POP指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD为16位(字)操作数,可以是寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"PUSH的操作过程是: (SP)<--(SP)-2,((sp))<--OPRD 即先修改堆栈指针SP(压入时为自动减2),然后,将指定的操作数送入新的栈顶位置.\\n此处的((SP))<--OPRD,也可以理解为: [(SS)*16+(SP)]<--OPRD 或 [SS:SP]<--OPRD\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"pushf\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pushf\"}},[v._v(\"#\")]),v._v(\" PUSHF\")]),v._v(\" \"),a(\"p\",[v._v(\"标志传送指令 PUSHF\\n格式: PUSHF\\n功能: 本指令可以把标志寄存器的内容保存到堆栈中去\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"rcl\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rcl\"}},[v._v(\"#\")]),v._v(\" RCL\")]),v._v(\" \"),a(\"p\",[v._v(\"循环移位指令\\n格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令.\\nROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令.\\nRCL OPRD1,COUNT ;带进位的左循环移位指令.\\nRCR OPRD1,COUNT ;带进位的右循环移位指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1.\")]),v._v(\" \"),a(\"li\",[v._v(\"由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入,\\n所以可以利用它实现多字节的循环.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"rcr\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rcr\"}},[v._v(\"#\")]),v._v(\" RCR\")]),v._v(\" \"),a(\"p\",[v._v(\"循环移位指令\\n格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令.\\nROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令.\\nRCL OPRD1,COUNT ;带进位的左循环移位指令.\\nRCR OPRD1,COUNT ;带进位的右循环移位指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1.\")]),v._v(\" \"),a(\"li\",[v._v(\"由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入,所以可以利用它实现多字节的循环.\\n注意: 以上程序中的指令SHR AL,CL如改为SAR AL,CL,虽然最高4位可移入低4位,但最高位不为0,故应加入一条指令AND AL,0FH.否则,若最高位不为0时,将得到错误结果.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"rep\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rep\"}},[v._v(\"#\")]),v._v(\" REP\")]),v._v(\" \"),a(\"p\",[v._v(\"重复前缀的说明\\n格式: REP ;CX<>0 重复执行字符串指令\\nREPZ/REPE ;CX<>0 且ZF＝1重复执行字符串指令\\nREPNZ/REPNE ;CX<>0 且ZF＝0重复执行字符串指令\\n功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"REP与MOVS或STOS串操作指令相结合使用,完成一组字符的传送或建立一组相同数据的字符串.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"repe\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repe\"}},[v._v(\"#\")]),v._v(\" REPE\")]),v._v(\" \"),a(\"p\",[v._v(\"重复前缀的说明\\n格式: REP ;CX<>0 重复执行字符串指令\\nREPZ/REPE ;CX<>0 且ZF＝1重复执行字符串指令\\nREPNZ/REPNE ;CX<>0 且ZF＝0重复执行字符串指令\\n功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"repne\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repne\"}},[v._v(\"#\")]),v._v(\" REPNE\")]),v._v(\" \"),a(\"p\",[v._v(\"重复前缀的说明\\n格式: REP ;CX<>0 重复执行字符串指令\\nREPZ/REPE ;CX<>0 且ZF＝1重复执行字符串指令\\nREPNZ/REPNE ;CX<>0 且ZF＝0重复执行字符串指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"repnz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repnz\"}},[v._v(\"#\")]),v._v(\" REPNZ\")]),v._v(\" \"),a(\"p\",[v._v(\"重复前缀的说明\\n格式: REP ;CX<>0 重复执行字符串指令\\nREPZ/REPE ;CX<>0 且ZF＝1重复执行字符串指令\\nREPNZ/REPNE ;CX<>0 且ZF＝0重复执行字符串指令\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"repz\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#repz\"}},[v._v(\"#\")]),v._v(\" REPZ\")]),v._v(\" \"),a(\"p\",[v._v(\"重复前缀的说明\\n格式: REP ;CX<>0 重复执行字符串指令\\nREPZ/REPE ;CX<>0 且ZF＝1重复执行字符串指令\\nREPNZ/REPNE ;CX<>0 且ZF＝0重复执行字符串指令\\n功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.\")]),v._v(\" \"),a(\"li\",[v._v(\"REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"ret\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ret\"}},[v._v(\"#\")]),v._v(\" RET\")]),v._v(\" \"),a(\"p\",[v._v(\"返回指令 RET\\n格式: RET\\n功能: 当调用的过程结束后实现从过程返回至原调用程序的下一条指令,本指令不影响标志位.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\n由于在过程定义时,已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作\\n对段内调用: 返回时,由堆栈弹出一个字的返回地址的段内偏移量至IP.\\n对段外调用: 返回时,由堆栈弹出的第一个字为返回地址的段内偏移量,将其送入IP中,由堆栈弹出第二个字为返回地址的段基址,将其送入CS中.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"rol\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rol\"}},[v._v(\"#\")]),v._v(\" ROL\")]),v._v(\" \"),a(\"p\",[v._v(\"循环移位指令\\n格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令.\\nROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令.\\nRCL OPRD1,COUNT ;带进位的左循环移位指令.\\nRCR OPRD1,COUNT ;带进位的右循环移位指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1.\")]),v._v(\" \"),a(\"li\",[v._v(\"由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入,\\n所以可以利用它实现多字节的循环.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"ror\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ror\"}},[v._v(\"#\")]),v._v(\" ROR\")]),v._v(\" \"),a(\"p\",[v._v(\"循环移位指令\\n格式:\\nROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令.\\nROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令.\\nRCL OPRD1,COUNT ;带进位的左循环移位指令.\\nRCR OPRD1,COUNT ;带进位的右循环移位指令.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1.\")]),v._v(\" \"),a(\"li\",[v._v(\"由于循环移位,所以对字节移位8次; 对字移位16次,可恢复为原操作数.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sahf\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sahf\"}},[v._v(\"#\")]),v._v(\" SAHF\")]),v._v(\" \"),a(\"p\",[v._v(\"标志传送指令 SAHF\\n格式: SAHF\\n功能: 将AH存至FLAG低8位\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 本指令将用AH的内容改写FLAG标志寄存器中的SF、ZF、AF、PF、和CF标志,从而改变原来的标志位.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sal\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sal\"}},[v._v(\"#\")]),v._v(\" SAL\")]),v._v(\" \"),a(\"p\",[v._v(\"算术左移指令 SAL(Shift Arithmetic Left)\\n格式: SAL OPRD1,COUNT\\n功能: 其中OPRD1,COUNT与指令SHL相同.本指令与SHL的功能也完全相同,这是因为逻辑左移指令与算术左移指令所要完成的操作是一样的.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sar\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sar\"}},[v._v(\"#\")]),v._v(\" SAR\")]),v._v(\" \"),a(\"p\",[v._v(\"算术右移指令 SAR\\n格式: SAR OPRD1,COUNT\\n功能: 本指令通常用于对带符号数减半的运算中,因而在每次右移时,保持最高位(符号位)不变,最低位右移至CF中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sbb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sbb\"}},[v._v(\"#\")]),v._v(\" SBB\")]),v._v(\" \"),a(\"p\",[v._v(\"带借位减去指令 SBB(SuBtraction with Borrow)\\n格式: SBB OPRD1,OPRD2\\n功能: 是进行两个操作数的相减再减去CF进位标志位,即从OPRD1<--OPRD1-OPRD2-CF,其结果放在OPDR1中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\n示例 SBB DX,CX\\nSBB AX,DATA1\\nSBB BX,2000H\\nSBB ALFA[BX+SI],SI\\nSBB BETAP[DI,030AH\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"scas\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scas\"}},[v._v(\"#\")]),v._v(\" SCAS\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串搜索指令 SCAS\\n格式: SCAS OPRD\\nSCASB\\nSCASW\\n功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身.\\n地址指针DI自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前,\\n把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找.\\n指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"scasb\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scasb\"}},[v._v(\"#\")]),v._v(\" SCASB\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串搜索指令 SCAS\\n格式: SCAS OPRD\\nSCASB\\nSCASW\\n功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身.\\n地址指针DI自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前,\\n把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找.\\n指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"scasw\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scasw\"}},[v._v(\"#\")]),v._v(\" SCASW\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串搜索指令 SCAS\\n格式: SCAS OPRD\\nSCASB\\nSCASW\\n功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身.\\n地址指针DI自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前,\\n把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找.\\n指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"shl\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#shl\"}},[v._v(\"#\")]),v._v(\" SHL\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑左移指令 SHL(Shift logical left)\\n格式: SHL OPRD1,COUNT\\n功能: 对给定的目的操作数左移COUNT次,每次移位时最高位移入标志位CF中,最低位补零.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.\")]),v._v(\" \"),a(\"li\",[v._v(\"例如: SHL AL,1\\nSHL CX,1\\nSHL ALFA[DI] 或者:\\nMOV CL,3\\nSHL DX,CL\\nSHL ALFA[DI],CL\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"shr\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#shr\"}},[v._v(\"#\")]),v._v(\" SHR\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑右移指令 SHR\\n格式: SHR OPRD1,COUNT\\n功能: 本指令实现由COUNT决定次数的逻辑右移操作,每次移位时,最高位补0,最低位移至标志位CF中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数.\")]),v._v(\" \"),a(\"li\",[v._v(\"COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.\")]),v._v(\" \"),a(\"li\",[v._v(\"影响标志位OF,PF,SF,ZF,CF.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"stc\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stc\"}},[v._v(\"#\")]),v._v(\" STC\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"std\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#std\"}},[v._v(\"#\")]),v._v(\" STD\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sti\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sti\"}},[v._v(\"#\")]),v._v(\" STI\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器控制指令－标志位操作指令\\n格式:\\nCLC ;置CF=0\\nSTC ;置CF=1\\nCMC ;置CF=(Not CF)进位标志求反\\nCLD ;置DF=0\\nSTD ;置DF＝1\\nCLI ;置IF=0，CPU禁止响应外部中断\\nSTI ;置IF=1，使CPU允许向应外部中断\\n功能: 完成对标志位的置位、复位等操作.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"stos\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stos\"}},[v._v(\"#\")]),v._v(\" STOS\")]),v._v(\" \"),a(\"p\",[v._v(\"字符串存储指令 STOS\\n格式: STOS OPRD\\n功能: 把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去.指针DI将根据DF的值进行自动调整.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"其中OPRD为目的串符号地址.\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响标志位.当不使用操作数时,可用STOSB或STOSW分别表示字节串或字串的操作.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"sub\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sub\"}},[v._v(\"#\")]),v._v(\" SUB\")]),v._v(\" \"),a(\"p\",[v._v(\"减法指令SUB(SUBtract)\\n格式: SUB OPRD1,OPRD2\\n功能: 两个操作数的相减,即从OPRD1中减去OPRD2,其结果放在OPDR1中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\\n示例 SUB DX,CX\\nSUB [BX+25],AX\\nSUB DI,ALFA[SI]\\nSUB CL,20\\nSUB DATA1[DI][BX],20A5H\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"test\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#test\"}},[v._v(\"#\")]),v._v(\" TEST\")]),v._v(\" \"),a(\"p\",[v._v(\"测试指令 TEST\\n格式: TEST OPRD1,OPRD2\\n功能: 其中OPRD1、OPRD2的含义同AND指令一样,也是对两个操作数进行按位的'与'运算,唯一不同之处是不将'与'的结\\n果送目的操作数,即本指令对两个操作数 的内容均不进行修改,仅是在逻辑与操作后,对标志位重新置位.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: TEST与AND指令的关系,有点类似于CMP与SUB指令之间的关系.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"wait\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#wait\"}},[v._v(\"#\")]),v._v(\" WAIT\")]),v._v(\" \"),a(\"p\",[v._v(\"处理器等待指令 WAIT\\n格式: WAIT\\n功能: 本指令将使处理器检测TEST端脚,当TEST有效时,则退出等待状态执行下条指令,否则处理器处于等待状态,直到TEST有效.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明: 本指令不影响标志位.\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"xchg\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xchg\"}},[v._v(\"#\")]),v._v(\" XCHG\")]),v._v(\" \"),a(\"p\",[v._v(\"数据交换指令 XCHG\\n格式: XCHG OPRD1,OPRD2 其中的OPRD1为目的操作数,OPRD2为源操作数\\n功能: 将两个操作数相互交换位置,该指令把源操作数OPRD2与目的操数OPRD1交换.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"OPRD1及OPRD2可为通用寄存器或存储器,但是两个存储器之间是不能用XCHG指令实现的.\")]),v._v(\" \"),a(\"li\",[v._v(\"段寄存器内容不能用XCHG指令来交换.\")]),v._v(\" \"),a(\"li\",[v._v(\"若要实现两个存储器操作数DATA1及DATA2的交换,可用以下指令实现:\\n示例: PUSH DATA1\\nPUSH DATA2\\nPOP DATA1\\nPOP DATA2\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响状态标志位.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"xlat\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xlat\"}},[v._v(\"#\")]),v._v(\" XLAT\")]),v._v(\" \"),a(\"p\",[v._v(\"查表指令 XLAT\\n格式: XLAT TABLE其中TABLE为一待查表格的首地址.\\n功能: 把待查表格的一个字节内容送到AL累加器中.\")]),v._v(\" \"),a(\"p\",[v._v(\"说明:\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"在执行该指令前,应将TABLE先送至BX寄存器中,然后将待查字节与在表格中距表首地址位移量送AL,即 (AL)<--((BX)+(AL)).\")]),v._v(\" \"),a(\"li\",[v._v(\"本指令不影响状态标位,表格长度不超过256字节.\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"xor\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xor\"}},[v._v(\"#\")]),v._v(\" XOR\")]),v._v(\" \"),a(\"p\",[v._v(\"逻辑异或运算指令 XOR\\n格式: XOR OPRD1,OPRD2\\n功能: 实现两个操作数按位‘异或’运算,结果送至目的操作数中.\\nOPRD1<--OPRD1 XOR OPRD2\")])])}),[],!1,null,null,null);_.default=s.exports}}]);","extractedComments":[]}